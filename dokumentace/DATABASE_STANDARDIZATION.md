# Standardizace p≈ô√≠stupu k datab√°zi - Neon PostgreSQL

## P≈ôehled zmƒõn

V r√°mci standardizace p≈ô√≠stupu k datab√°zi jsme provedli n√°sleduj√≠c√≠ zmƒõny:

1. **Unifikovan√Ω klient** - V≈°echny datab√°zov√© skripty nyn√≠ pou≈æ√≠vaj√≠ `@neondatabase/serverless` klienta
2. **Konzistentn√≠ zp≈Øsob dotazov√°n√≠** - Pou≈æit√≠ template strings m√≠sto p≈ô√≠m√©ho SQL
3. **Lep≈°√≠ zpracov√°n√≠ chyb** - Oddƒõlen√© zpracov√°n√≠ chyb pro ka≈æd√Ω p≈ô√≠kaz
4. **ES Modules** - P≈ôechod na import/export syntaxi a .mjs soubory

## Struktura datab√°ze

Datab√°ze obsahuje n√°sleduj√≠c√≠ hlavn√≠ tabulky:

| Tabulka | Popis |
|---------|-------|
| `articles` | ƒål√°nky a aktuality |
| `categories` | Kategorie pro ƒçl√°nky |
| `settings` | Nastaven√≠ syst√©mu |
| `users` | U≈æivatel√© syst√©mu (admin p≈ô√≠stupy) |
| `users_sync` | Synchronizace u≈æivatelsk√Ωch dat |
| `newsletter_subscribers` | Odbƒõratel√© newsletteru |
| `newsletter_templates` | ≈†ablony pro newsletter |
| `newsletter_campaigns` | Kampanƒõ a rozes√≠lky newsletteru |

### Diagram vztah≈Ø

```
articles -------> categories
    |
    v
newsletter_campaigns --> newsletter_templates
    |
    v
newsletter_subscribers
```

### D≈Øle≈æit√© sloupce a konvence

- Prim√°rn√≠ kl√≠ƒçe jsou obvykle typu `uuid` generovan√© pomoc√≠ `gen_random_uuid()`
- Timestampy pou≈æ√≠vaj√≠ `created_at` a `updated_at` (snake_case v datab√°zi)
- Pro boolean hodnoty se pou≈æ√≠v√° konvence `is_something` (nap≈ô. `is_published`)
- Textov√© sloupce pou≈æ√≠vaj√≠ datov√Ω typ `text` m√≠sto `varchar` pro flexibilitu
5. **Pomocn√© funkce** - Nov√© funkce pro ƒçasto pou≈æ√≠van√© operace (executeSafely, runSqlFile, tableExists)

## Jak pou≈æ√≠vat standardizovan√Ω p≈ô√≠stup k datab√°zi

### 1. P≈ôipojen√≠ k datab√°zi

```javascript
import 'dotenv/config'
import { neon } from '@neondatabase/serverless'

const connectionString = process.env.DATABASE_URL;
if (!connectionString) {
  console.error('‚ùå DATABASE_URL environment variable is not set');
  process.exit(1);
}

// Vytvo≈ôen√≠ Neon klienta - nen√≠ pot≈ôeba connect() a end()
const sql = neon(connectionString);
```

### 2. Dotazov√°n√≠ pomoc√≠ template strings

```javascript
// Dotaz bez parametr≈Ø
const result = await sql`SELECT * FROM articles LIMIT 10`;

// Dotaz s parametry (automaticky o≈°et≈ôeno proti SQL injection)
const title = 'Nov√Ω ƒçl√°nek';
const content = 'Obsah ƒçl√°nku...';
const result = await sql`
  INSERT INTO articles (title, content) 
  VALUES (${title}, ${content}) 
  RETURNING *
`;
```

### 3. Spou≈°tƒõn√≠ SQL souboru

Pro spu≈°tƒõn√≠ SQL souboru m≈Ø≈æete pou≈æ√≠t tuto helper funkci, kter√° rozdƒõl√≠ obsah souboru na jednotliv√© p≈ô√≠kazy:

```javascript
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

async function runSqlFile(filePath) {
  try {
    const fullPath = path.join(__dirname, '..', filePath);
    console.log(`üìÑ Naƒç√≠t√°n√≠ SQL souboru: ${filePath}...`);
    
    if (!fs.existsSync(fullPath)) {
      console.warn(`‚ö†Ô∏è SQL soubor nenalezen: ${filePath}`);
      return false;
    }
    
    const sqlContent = fs.readFileSync(fullPath, 'utf8');
    const statements = sqlContent
      .split(';')
      .map(stmt => stmt.trim())
      .filter(stmt => stmt.length > 0);
    
    console.log(`üìù Prov√°dƒõn√≠ ${statements.length} SQL p≈ô√≠kaz≈Ø...`);
    
    for (let i = 0; i < statements.length; i++) {
      const statement = statements[i];
      try {
        console.log(`   ${i + 1}/${statements.length}: ${statement.substring(0, 50)}...`);
        await sql`${statement}`;
      } catch (error) {
        if (error.message.includes('already exists')) {
          console.log(`   ‚ö†Ô∏è P≈ôeskoƒçeno (ji≈æ existuje): ${error.message}`);
        } else {
          throw error;
        }
      }
    }
    
    return true;
  } catch (error) {
    console.error(`‚ùå Chyba p≈ôi spou≈°tƒõn√≠ SQL souboru: ${error.message}`);
    return false;
  }
}
```

### 4. Bezpeƒçn√© spou≈°tƒõn√≠ jednotliv√Ωch SQL p≈ô√≠kaz≈Ø

```javascript
async function executeSafely(description, statement) {
  console.log(`üîπ ${description}...`);
  try {
    await sql`${statement}`;
    console.log(`   ‚úÖ Hotovo`);
    return true;
  } catch (error) {
    if (error.message.includes('already exists')) {
      console.log(`   ‚ö†Ô∏è P≈ôeskoƒçeno (ji≈æ existuje): ${error.message}`);
      return true;
    } else {
      console.error(`   ‚ùå Chyba: ${error.message}`);
      return false;
    }
  }
}

// Pou≈æit√≠
await executeSafely('Vytv√°≈ôen√≠ tabulky users', `
  CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    name TEXT
  )
`);
```

## Seznam upraven√Ωch skript≈Ø

1. `scripts/setup-schema.mjs` - Vytvo≈ôen√≠ sch√©matu datab√°ze
2. `scripts/test-db.js` -> `scripts/test-db.mjs` - Test p≈ôipojen√≠ k datab√°zi
3. `scripts/setup-database.js` -> `scripts/setup-database.mjs` - Nastaven√≠ z√°kladn√≠ho sch√©matu

## P≈ô√≠klady pou≈æit√≠ pro r≈Øzn√© operace

### Vytvo≈ôen√≠/aktualizace tabulky

```javascript
await executeSafely('Vytv√°≈ôen√≠ tabulky articles', `
  CREATE TABLE IF NOT EXISTS articles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    slug TEXT UNIQUE NOT NULL,
    title TEXT NOT NULL,
    content TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    category TEXT,
    image_url TEXT,
    is_published BOOLEAN DEFAULT TRUE
  )
`);
```

### Vytvo≈ôen√≠ indexu

```javascript
await executeSafely('Vytv√°≈ôen√≠ indexu', `
  CREATE INDEX IF NOT EXISTS idx_articles_category ON articles(category)
`);
```

### Vlo≈æen√≠ dat

```javascript
const email = 'admin@example.com';
const hashedPassword = await bcrypt.hash('heslo123', 10);

const result = await sql`
  INSERT INTO users_sync (email, hashed_password, is_admin, name)
  VALUES (${email}, ${hashedPassword}, ${true}, ${'Administrator'})
  ON CONFLICT (email) DO NOTHING
`;
```

### Kontrola existence tabulky

```javascript
async function tableExists(tableName) {
  const result = await sql`
    SELECT EXISTS (
      SELECT FROM information_schema.tables 
      WHERE table_name = ${tableName}
      AND table_schema = 'public'
    ) AS exists
  `;
  return result[0].exists;
}

// Pou≈æit√≠
if (await tableExists('users_sync')) {
  console.log('Tabulka users_sync existuje');
} else {
  console.log('Tabulka users_sync neexistuje');
}
```

## Shrnut√≠ v√Ωhod nov√©ho p≈ô√≠stupu

1. **Bezpeƒçnost** - Parametry SQL dotaz≈Ø jsou automaticky escapovan√©
2. **Jednotnost** - V≈°echny skripty pou≈æ√≠vaj√≠ stejn√Ω p≈ô√≠stup
3. **Modularita** - Opakuj√≠c√≠ se operace jsou v pomocn√Ωch funkc√≠ch
4. **Lep≈°√≠ zpracov√°n√≠ chyb** - Skripty l√©pe reaguj√≠ na chybov√© stavy
5. **Modern√≠ syntaxe** - Pou≈æit√≠ ES Modules a template strings

## Celkov√Ω p≈ôehled standardizace

### üß± Standardizace p≈ôipojen√≠ k datab√°zi
- P≈ôechod na @neondatabase/serverless pro modern√≠, ≈°k√°lovateln√© p≈ôipojen√≠
- Modularizace pomoc√≠ helper funkc√≠ pro bezpeƒçnƒõj≈°√≠ pr√°ci se SQL
- Odstranƒõn√≠ nutnosti manu√°lnƒõ volat connect() a end() - Neon klient to ≈ôe≈°√≠ automaticky

## ≈òe≈°en√≠ ƒçast√Ωch probl√©m≈Ø

### Chyba "syntax error at or near "$1"" p≈ôi pou≈æit√≠ `sql\`${statement}\``

P≈ôi pou≈æit√≠ SQL dotazu uvnit≈ô template stringu m≈Ø≈æe doch√°zet k chybƒõ "syntax error at or near "$1"", proto≈æe Neon klient interpretuje ${...} uvnit≈ô template stringu nespr√°vnƒõ. Existuj√≠ dva zp≈Øsoby ≈ôe≈°en√≠:

#### 1. Pou≈æit√≠ raw SQL dotazu pomoc√≠ sql.raw()

```javascript
// Nam√≠sto:
await sql`${statement}`;

// Pou≈æijte:
await sql.raw(statement);
```

#### 2. P≈ô√≠m√© vlo≈æen√≠ SQL dotazu bez parametrizace (jen pro statick√© dotazy)

```javascript
// Statick√© dotazy bez u≈æivatelsk√©ho vstupu lze zapsat p≈ô√≠mo:
await sql`CREATE TABLE IF NOT EXISTS articles (id SERIAL PRIMARY KEY, title TEXT NOT NULL)`;

// Pro dynamick√© dotazy pou≈æijte parametrizaci:
const tableName = 'articles';
const columnName = 'title';
await sql`CREATE INDEX IF NOT EXISTS idx_${tableName}_${columnName} ON ${sql(tableName)}(${sql(columnName)})`;
```

#### 3. √öprava funkce executeSafely

```javascript
async function executeSafely(description, statement) {
  console.log(`üîπ ${description}...`);
  try {
    // Pou≈æit√≠ sql.raw m√≠sto sql`${statement}`
    await sql.raw(statement);
    console.log(`   ‚úÖ Hotovo`);
    return true;
  } catch (error) {
    if (error.message.includes('already exists')) {
      console.log(`   ‚ö†Ô∏è P≈ôeskoƒçeno (ji≈æ existuje): ${error.message}`);
      return true;
    } else {
      console.error(`   ‚ùå Chyba: ${error.message}`);
      return false;
    }
  }
}

### üîç Validace sch√©matu & opravy
- O≈°et≈ôen√° kontrola existence tabulek/sloupc≈Ø pomoc√≠ specializovan√Ωch funkc√≠
- Skript `create-users-sync-table.mjs` se star√° o inicializaci chybƒõj√≠c√≠ tabulky
- P≈ôid√°na mo≈ænost vytvo≈ôit admin u≈æivatele p≈ôes promƒõnn√© prost≈ôed√≠ (.env)
- Preventivn√≠ detekce a ≈ôe≈°en√≠ probl√©m≈Ø s datab√°zov√Ωm sch√©matem

### üìê Sjednocen√≠ n√°zv≈Ø sloupc≈Ø
- Detekce rozd√≠lu mezi `published` vs. `is_published`
- Skript `unify-published-column-names.mjs` zajistil jednotnost nap≈ô√≠ƒç datab√°z√≠
- Ostatn√≠ skripty byly upraveny pro kompatibilitu s jednotn√Ωm n√°zvoslov√≠m

### üì¶ Zmƒõny v package.json
- Nov√© npm skripty pro jednotliv√© operace (`db:test`, `db:schema`, `db:users-sync`, `db:unify`)
- `db:setup-all` jako hlavn√≠ orchestr√°tor nastaven√≠ cel√© datab√°ze
- Modernizace skript≈Ø a nahrazen√≠ zastaral√Ωch inline p≈ô√≠kaz≈Ø

### üìö Dokumentace
- Vytvo≈ôen soubor `DATABASE_STANDARDIZATION.md` pro intern√≠ technick√Ω p≈ôehled
- Aktualizov√°n `README.md` pro v√Ωvoj√°≈ôe i onboarding
- P≈ô√≠klady pou≈æit√≠ pro v≈°echny bƒõ≈æn√© datab√°zov√© operace

### üß¨ K√≥dov√° z√°kladna ‚Äì database.ts
- Nov√© helper funkce pro kontrolu existence tabulek a sloupc≈Ø
- Modernizace pro ƒçist≈°√≠ pr√°ci s Neon PostgreSQL
- Centralizovan√Ω p≈ô√≠stup k datab√°zi pro cel√Ω projekt

## Instalace a z√°vislosti

Pro spr√°vn√Ω bƒõh skript≈Ø je pot≈ôeba nainstalovat n√°sleduj√≠c√≠ z√°vislosti:

```bash
# Instalace z√°kladn√≠ch z√°vislost√≠
pnpm add @neondatabase/serverless dotenv bcrypt

# Instalace pomocn√Ωch n√°stroj≈Ø pro v√Ωvoj
pnpm add tsx --save-dev
```

### Pot≈ôebn√© z√°vislosti

1. **@neondatabase/serverless** - Hlavn√≠ klient pro p≈ôipojen√≠ k Neon PostgreSQL
2. **dotenv** - Pro naƒçten√≠ promƒõnn√Ωch prost≈ôed√≠
3. **bcrypt** - Pro hashov√°n√≠ hesel p≈ôi vytv√°≈ôen√≠ u≈æivatel≈Ø
4. **tsx** (dev) - Pro spou≈°tƒõn√≠ TypeScript soubor≈Ø bez nutnosti kompilace

Tyto z√°vislosti jsou ji≈æ p≈ôid√°ny do `package.json`, tak≈æe vƒõt≈°inou staƒç√≠ jen spustit `pnpm install` nebo `npm install`.

## P≈ô√≠klady pou≈æit√≠

### P≈ôipojen√≠ k datab√°zi

```typescript
// lib/database.ts
import { neon } from '@neondatabase/serverless';
import dotenv from 'dotenv';

dotenv.config();

export const sql = neon(process.env.DATABASE_URL);
```

### Jednoduch√Ω dotaz

```typescript
// p≈ô√≠klad pou≈æit√≠ v service vrstvƒõ
import { sql } from '../lib/database';

export async function getAllArticles() {
  try {
    const articles = await sql`
      SELECT * FROM articles 
      WHERE is_published = true 
      ORDER BY created_at DESC
    `;
    return articles;
  } catch (error) {
    console.error('Chyba p≈ôi naƒç√≠t√°n√≠ ƒçl√°nk≈Ø:', error);
    return [];
  }
}
```

### Parametrizovan√© dotazy

```typescript
// bezpeƒçn√© pou≈æit√≠ parametr≈Ø
async function getArticleById(id) {
  return await sql`SELECT * FROM articles WHERE id = ${id}`;
}

// pr√°ce s v√≠ce parametry
async function searchArticles({ category, searchTerm, limit = 10 }) {
  return await sql`
    SELECT * FROM articles 
    WHERE 
      category = ${category} AND
      (title ILIKE ${'%' + searchTerm + '%'} OR 
       content ILIKE ${'%' + searchTerm + '%'})
    LIMIT ${limit}
  `;
}
```

### Vkl√°d√°n√≠ dat

```typescript
// vlo≈æen√≠ nov√©ho ƒçl√°nku
async function createArticle(articleData) {
  const { title, content, category_id, is_published } = articleData;
  
  return await sql`
    INSERT INTO articles (title, content, category_id, is_published, created_at, updated_at)
    VALUES (
      ${title}, 
      ${content}, 
      ${category_id}, 
      ${is_published},
      NOW(),
      NOW()
    )
    RETURNING *
  `;
}
```

### Transakce

```typescript
// pou≈æit√≠ transakc√≠ pro v√≠ce souvisej√≠c√≠ch operac√≠
import { neon } from '@neondatabase/serverless';
import dotenv from 'dotenv';

dotenv.config();

async function createArticleWithTags(articleData, tags) {
  const client = neon(process.env.DATABASE_URL);
  
  try {
    // zaƒç√°tek transakce
    await client.query('BEGIN');
    
    // vlo≈æen√≠ ƒçl√°nku
    const articleResult = await client.query(
      'INSERT INTO articles (title, content) VALUES ($1, $2) RETURNING id',
      [articleData.title, articleData.content]
    );
    
    const articleId = articleResult[0].id;
    
    // vlo≈æen√≠ tag≈Ø
    for (const tag of tags) {
      await client.query(
        'INSERT INTO article_tags (article_id, tag_name) VALUES ($1, $2)',
        [articleId, tag]
      );
    }
    
    // potvrzen√≠ transakce
    await client.query('COMMIT');
    
    return articleId;
  } catch (error) {
    // vr√°cen√≠ zmƒõn p≈ôi chybƒõ
    await client.query('ROLLBACK');
    throw error;
  }
}
```

## ƒåast√© chyby a ≈ôe≈°en√≠

### Chyba p≈ôi spu≈°tƒõn√≠ skriptu: "Error: Cannot find module 'bcrypt'"

**≈òe≈°en√≠:** Nainstalujte chybƒõj√≠c√≠ z√°vislost:
```bash
pnpm add bcrypt
# nebo
npm install bcrypt
```

### Chyba p≈ôi prov√°dƒõn√≠ SQL dotaz≈Ø: "syntax error at or near "$1""

Tato chyba se objevuje p≈ôi nespr√°vn√©m pou≈æit√≠ parametrizovan√Ωch dotaz≈Ø. V Neon klientu je pot≈ôeba pou≈æ√≠t speci√°ln√≠ funkci `sql` pro template strings.

**Nespr√°vnƒõ:**
```typescript
const query = `CREATE TABLE IF NOT EXISTS ${tableName} (id SERIAL PRIMARY KEY)`;
await client.query(query);
```

**Spr√°vnƒõ:**
```typescript
import { sql } from '@neondatabase/serverless';

const query = sql.raw(`CREATE TABLE IF NOT EXISTS ${tableName} (id SERIAL PRIMARY KEY)`);
await client.query(query);
```

### Chyba p≈ôipojen√≠: "Could not connect to database"

1. Zkontrolujte, zda m√°te spr√°vn√Ω DATABASE_URL v souboru .env
2. Ovƒõ≈ôte, ≈æe datab√°ze je p≈ô√≠stupn√° (firewall, VPN)
3. Zkontrolujte, zda p≈ôihla≈°ovac√≠ √∫daje jsou spr√°vn√©

**Tip:** Pro testov√°n√≠ p≈ôipojen√≠ m≈Ø≈æete pou≈æ√≠t jednoduch√Ω skript:

```typescript
// test-connection.mjs
import { neon } from '@neondatabase/serverless';
import dotenv from 'dotenv';

dotenv.config();

async function testConnection() {
  const sql = neon(process.env.DATABASE_URL);
  
  try {
    const result = await sql`SELECT 1 as connection_test`;
    console.log("P≈ôipojen√≠ √∫spƒõ≈°n√©:", result);
  } catch (error) {
    console.error("Chyba p≈ôipojen√≠:", error);
  }
}

testConnection();
```

### Nastaven√≠ promƒõnn√Ωch prost≈ôed√≠

Pro spr√°vnou funkci skript≈Ø je pot≈ôeba nastavit promƒõnn√© prost≈ôed√≠ v souboru `.env` nebo `.env.local`:

```
DATABASE_URL=postgres://user:password@host:port/database

# Voliteln√© pro vytvo≈ôen√≠ admin u≈æivatele
ADMIN_EMAIL=admin@example.com
ADMIN_PASSWORD=bezpecne_heslo
```

## Proces migrace a spr√°va datab√°zov√©ho sch√©matu

### Standardn√≠ postup p≈ôi zmƒõnƒõ sch√©matu

1. **√öprava sch√©matu v k√≥du**:
   - Aktualizujte soubor `lib/schema.ts` s nov√Ωmi definicemi tabulek nebo sloupc≈Ø
   - Ujistƒõte se, ≈æe v≈°echny entity maj√≠ spr√°vn√© n√°zvy (camelCase v k√≥du, snake_case v DB)

2. **Vytvo≈ôen√≠ migraƒçn√≠ho skriptu**:
   - Vytvo≈ôte nov√Ω skript v adres√°≈ôi `scripts/` s p≈ô√≠ponou `.mjs`
   - Pou≈æijte standardn√≠ strukturu s importy, main funkc√≠ a error handlingem

3. **Testov√°n√≠ migrace lok√°lnƒõ**:
   - Spus≈•te skript pomoc√≠ `pnpm tsx scripts/nazev-skriptu.mjs`
   - Ovƒõ≈ôte, ≈æe zmƒõny byly spr√°vnƒõ aplikov√°ny

4. **Nasazen√≠ do produkce**:
   - P≈ôed produkƒçn√≠m nasazen√≠m v≈ædy vytvo≈ôte z√°lohu dat
   - Spus≈•te migraci v produkƒçn√≠m prost≈ôed√≠
   - Zkontrolujte, ≈æe aplikace funguje spr√°vnƒõ s nov√Ωm sch√©matem

### ≈†ablona migraƒçn√≠ho skriptu

P≈ôi vytv√°≈ôen√≠ nov√Ωch migraƒçn√≠ch skript≈Ø pou≈æ√≠vejte n√°sleduj√≠c√≠ ≈°ablonu:

```typescript
// scripts/migrate-xyz.mjs
import { neon } from '@neondatabase/serverless';
import dotenv from 'dotenv';

dotenv.config();

const sql = neon(process.env.DATABASE_URL);

async function executeSafely(query, description) {
  try {
    const result = await query;
    console.log(`‚úÖ ${description}: √öspƒõch`);
    return result;
  } catch (error) {
    console.error(`‚ùå ${description}: Chyba`, error);
    return null;
  }
}

async function main() {
  console.log('üöÄ Zah√°jen√≠ migrace...');
  
  // P≈ô√≠klad migraƒçn√≠ho p≈ô√≠kazu
  await executeSafely(
    sql.raw(`ALTER TABLE tabulka ADD COLUMN novy_sloupec TEXT`),
    'P≈ôid√°n√≠ nov√©ho sloupce'
  );
  
  console.log('‚ú® Migrace dokonƒçena');
}

main().catch((error) => {
  console.error('‚ùå Kritick√° chyba:', error);
  process.exit(1);
});
```

## Z√°lohov√°n√≠ a obnova dat

### Vytvo≈ôen√≠ z√°lohy dat

Pro vytvo≈ôen√≠ z√°lohy dat z Neon PostgreSQL m≈Ø≈æete pou≈æ√≠t n√°sleduj√≠c√≠ skript:

```typescript
// scripts/backup-data.mjs
import { neon } from '@neondatabase/serverless';
import dotenv from 'dotenv';
import fs from 'fs/promises';
import path from 'path';

dotenv.config();

const sql = neon(process.env.DATABASE_URL);
const BACKUP_FOLDER = path.join(process.cwd(), 'data', 'backups');

async function backupTable(tableName) {
  try {
    const data = await sql.raw(`SELECT * FROM ${tableName}`);
    const timestamp = new Date().toISOString().replace(/:/g, '-');
    const fileName = `${tableName}-${timestamp}.json`;
    const filePath = path.join(BACKUP_FOLDER, fileName);
    
    await fs.mkdir(BACKUP_FOLDER, { recursive: true });
    await fs.writeFile(filePath, JSON.stringify(data, null, 2));
    
    console.log(`‚úÖ Z√°loha tabulky ${tableName} ulo≈æena do: ${filePath}`);
    return filePath;
  } catch (error) {
    console.error(`‚ùå Chyba p≈ôi z√°lohov√°n√≠ tabulky ${tableName}:`, error);
    return null;
  }
}

async function main() {
  console.log('üöÄ Zah√°jen√≠ z√°lohov√°n√≠...');
  
  // Seznam tabulek k z√°lohov√°n√≠
  const tables = [
    'articles',
    'categories',
    'settings',
    'users',
    'newsletter_subscribers',
    'newsletter_templates',
    'newsletter_campaigns'
  ];
  
  for (const table of tables) {
    await backupTable(table);
  }
  
  console.log('‚ú® Z√°lohov√°n√≠ dokonƒçeno');
}

main().catch((error) => {
  console.error('‚ùå Kritick√° chyba:', error);
  process.exit(1);
});
```

### Obnova dat ze z√°lohy

```typescript
// scripts/restore-data.mjs
import { neon } from '@neondatabase/serverless';
import dotenv from 'dotenv';
import fs from 'fs/promises';
import path from 'path';

dotenv.config();

const client = neon(process.env.DATABASE_URL);

async function restoreTable(filePath, tableName) {
  try {
    // Naƒçten√≠ dat ze z√°lo≈æn√≠ho souboru
    const fileContent = await fs.readFile(filePath, 'utf8');
    const data = JSON.parse(fileContent);
    
    if (!data.length) {
      console.log(`‚ÑπÔ∏è ≈Ω√°dn√° data k obnoven√≠ pro tabulku ${tableName}`);
      return;
    }
    
    // Z√≠sk√°n√≠ n√°zv≈Ø sloupc≈Ø z prvn√≠ho objektu
    const columns = Object.keys(data[0]);
    
    // Zaƒç√°tek transakce
    await client.query('BEGIN');
    
    // Vymaz√°n√≠ existuj√≠c√≠ch dat
    await client.query(`TRUNCATE TABLE ${tableName} CASCADE`);
    
    // Vlo≈æen√≠ dat po ≈ô√°dc√≠ch
    for (const row of data) {
      const values = columns.map(col => row[col]);
      const placeholders = columns.map((_, i) => `$${i + 1}`).join(', ');
      
      await client.query(
        `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES (${placeholders})`,
        values
      );
    }
    
    // Potvrzen√≠ transakce
    await client.query('COMMIT');
    
    console.log(`‚úÖ Obnovena data pro tabulku ${tableName} (${data.length} z√°znam≈Ø)`);
  } catch (error) {
    // Vr√°cen√≠ zmƒõn p≈ôi chybƒõ
    await client.query('ROLLBACK');
    console.error(`‚ùå Chyba p≈ôi obnovov√°n√≠ tabulky ${tableName}:`, error);
  }
}

async function main() {
  // Cesta k z√°loze a n√°zev tabulky
  const backupFile = process.argv[2];
  const tableName = process.argv[3];
  
  if (!backupFile || !tableName) {
    console.error('‚ùå Chyb√≠ cesta k z√°loze nebo n√°zev tabulky.');
    console.log('Pou≈æit√≠: pnpm tsx scripts/restore-data.mjs cesta/k/souboru.json nazev_tabulky');
    process.exit(1);
  }
  
  console.log(`üöÄ Zah√°jen√≠ obnovy tabulky ${tableName} ze souboru ${backupFile}...`);
  await restoreTable(backupFile, tableName);
  console.log('‚ú® Obnova dokonƒçena');
}

main().catch((error) => {
  console.error('‚ùå Kritick√° chyba:', error);
  process.exit(1);
});
```
